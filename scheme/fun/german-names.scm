(library (sph fun german-names)
  (export
    display-german-names
    make-german-names
    sph-fun-german-names-description)
  (import
    (rnrs exceptions)
    (sph)
    (sph alist)
    (sph hashtable)
    (sph lang config)
    (sph list)
    (sph list one)
    (only (guile) make-list))

  (define sph-fun-german-names-description "create funny german animal/place/band-names")

  (define-as config list-q
    "lumpen" (s2)
    "uppen" (p1 p2)
    "ippen" (p1 p2)
    "dach" (p2)
    "kunzel" (p1)
    "hühner" (s2)
    "dödel" (p1 p2 s2)
    "huber" (s1)
    "buben" (s2)
    "möwen" (p1 p2 s2)
    "bier" (p2)
    "beisser" (s2)
    "schluchten" (p2)
    "popper" (s2)
    "geier" (s2)
    "alpen" (p1 p2)
    "brei" (s2)
    "feld" ((s1 "er") (p2))
    "ober" (p1)
    "unter" (p1)
    "nieder" (p1)
    "dohle" (s2)
    "höcker" (p2)
    "lach" (p2)
    "silber" (p1 p2)
    "stein" (s1 s2 p2)
    "feuer" (p2)
    "trottel" (p2 s2)
    "schwitzer" (s2)
    "felsen" (s2)
    "bogen" (s1)
    "affe" ((p1 "n") (s2 "" "n"))
    "bacher" (s1)
    "backen" (s2)
    "berg" ((p1 "en") p2 (s1 "er"))
    "binkel" (p1)
    "bratz" ((p1 "en") (p2 "en") (s2 "e" "en"))
    "brecher" (s1)
    "brenner" (s1)
    "burg" ((p1 "en") (p2 "") (s1 "er"))
    "bursch" ((s2 "en"))
    "docht" (p2)
    "luder" (s2)
    "donner" (p1 s2)
    "dorfer" (s1)
    "geissen" (p1)
    "dörfer" (s1)
    "dom" (s2)
    "ummen" (p1)
    "balg" (s2)
    "bürzel" (s2)
    "drossel" (s2)
    "tümp" ((p1 "el") (s1 "ler") (s2 "ler"))
    "dümpel" (p1 s2)
    "espen" (p1)
    "ferkel" (p2)
    "fink" (s2)
    "finkel" (p1)
    "franzel" (p1 p2)
    "furt" ((s1 "er"))
    "fürsten" (p1 p2)
    "drücker" (s2)
    "hauser" (s1)
    "heimer" (s1)
    "hinter" (p1 p2)
    "hopfen" (p1 p2)
    "husen" (p1 s2)
    "häuser" (s1)
    "häuser" (s1)
    "höfer" (s1)
    "süffel" (p2)
    "hült" ((p1 "en") (s1 "er"))
    "jauch" ((s2 "e"))
    "leier" (p2)
    "linger" (s1)
    "länder" (s1)
    "mürgen" (p1 p2)
    "neppel" (p1 p2)
    "ochsen" (p1 p2 s2)
    "offel" (p1)
    "onkel" (p1)
    "poppel" (p1 p2)
    "proppen" (s2)
    "ruppel" (p1 p2)
    "zapfen" (p2 s2)
    "schaufel" (p1)
    "schemmel" (p1 s2)
    "schmeckel" (p1)
    "schmuck" ((p1 "en" "") p2)
    "setz" (p1)
    "sippel" (p1 p2 s2)
    "sprochsel" (s2)
    "stein" (p1 (s1 "er"))
    "stelz" ((p1 "en") (s2 "e"))
    "stink" ((p1 "en") (s1 "er"))
    "stoffel" (p1)
    "straat" (p1 (s1 "er"))
    "stulz" ((p1 "en") (s1 "er"))
    "stätt" ((p1 "en") (s1 "er"))
    "sumpfel" (p1 p2)
    "suppen" (p2)
    "sümpfel" (p1 p2)
    "taler" (s1)
    "tüten" (s2)
    "ulken" (p1)
    "unger" (s1 p1)
    "uter" (s1)
    "walder" (s1)
    "walz" ((s2 "er"))
    "wanz" ((p1 "en") (s2 "e"))
    "wipfel" (s2)
    "wurz" ((p1 "en" "el") s2)
    "wälder" (s1)
    "zipfel" (p1 s2)
    "zipfler" (s1 s2)
    "zung" ((p2 "en") (s2))
    "ült" ((p1 "en") (s1 "er"))
    ;(w1 "ppel" (("" "s" "n" "m" "f" "p") ("a" "o" "ü"))) (p1 s1 p2 s2)
    ;(w1 ("kk" "g" "gg") (("h" "f" "m" "s" "sch" "n" "g") ("a" "o" "ö" "ü" "e"))) ((p1 "el") (s1 "ler" "er") (s2 "ler" "e" "er"))
    )

  (define* (w1 base #:optional p s) "constructs bases by appending or prepending strings"
    (let
      ( (b (any->list base))
        (p (or (and p (apply produce string-append (map any->list (any->list p)))) (list "")))
        (s (or (and s (apply produce string-append (map any->list (any->list s)))) (list ""))))
      (produce string-append p b s)))

  (define-as base-constructors ht-create-binding w1)

  (define (make-bases base)
    (cond ((string? base) (list base))
      ((list? base) (apply (ht-ref base-constructors (first base)) (tail base)))
      (else (raise (q invalid-base-specified)))))

  (define (get-config)
    (apply append
      (map-slice 2
        (l (base suffixes)
          (let ((bases (make-bases base)) (suffixes (map any->list (any->list suffixes))))
            (map (l (b) (pair b suffixes)) bases)))
        config)))

  (define (prepend-unique gen tries lis)
    (let (a (gen)) (if (contains? lis a) (prepend-unique gen (- tries 1) lis) (pair a lis))))

  (define (prepend-retry-duplicates gen tries lis)
    (let (a (gen))
      (if (and (containsq? lis a) (< 0 tries)) (prepend-retry-duplicates gen (- tries 1) lis)
        (pair a lis))))

  (define (config-filter config key)
    (filter (l (a) (let (suffixes (tail a)) (alist-ref suffixes key))) config))

  (define (make-one-word base suffixes key)
    (let (a (alist-ref suffixes key))
      (if a (if (null? a) base (string-append base (list-ref-random a))) null)))

  (define (two-words-getter config) (config-filter config (q s1))
    (let
      ( (p1 (config-filter config (q p1))) (s1 (config-filter config (q s1)))
        (p2 (config-filter config (q p2))) (s2 (config-filter config (q s2))))
      (l (count)
        (map-slice 4
          (l (p1 s1 p2 s2)
            (string-append (make-one-word (first p1) (tail p1) (q p1))
              (make-one-word (first s1) (tail s1) (q s1)) " "
              (make-one-word (first p2) (tail p2) (q p2)) (make-one-word (first s2) (tail s2) (q s2))))
          (fold-right
            (l (parts result)
              (prepend-retry-duplicates (nullary (list-ref-random parts)) 20 result))
            (list) (apply append (make-list count (list p1 s1 p2 s2))))))))

  (define make-german-names (two-words-getter (get-config)))
  (define (display-german-names count) (each display-line (make-german-names count))))
