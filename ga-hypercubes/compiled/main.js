// Generated by CoffeeScript 2.7.0
(function() {
  // depends on https://github.com/weshoke/versor.js, https://github.com/KoryNunn/crel.
  // * the first part of the file defines helper routines
  // * the "cube" function is the main drawing function
  // * ui_controls is for the html controls form
  var array_copy, array_new, binomial, false_if_nan, integer_to_bitvector, k_cube_vectors, render_rotating_cube, ui_controls;

  array_new = function(size, init) {
    var a;
    a = Array(size);
    if (init != null) {
      return a.fill(init);
    } else {
      return a;
    }
  };

  array_copy = function(a) {
    return a.slice();
  };

  false_if_nan = function(a) {
    if (isNaN(a)) {
      return false;
    } else {
      return a;
    }
  };

  integer_to_bitvector = function(a, k) {};

  binomial = function(n, k) {
    // binomial coefficient (n choose k)
    if (k === 0 || k === n) {
      return 1;
    } else {
      return (n * binomial(n - 1, k - 1)) / k;
    }
  };

  k_cube_vectors = function(k) {
    var a, b, c, cell_indices, edge_indices, fixed, i, j, l, len, len1, len2, m, o, ref, ref1, ref2, vertices;
    // create bit patterns up to 2 ** k as integers
    vertices = (function() {
      var results = [];
      for (var j = 0, ref = 2 ** k; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this);
    edge_indices = [];
    cell_indices = [];
// get edges
    for (j = 0, len = vertices.length; j < len; j++) {
      a = vertices[j];
      for (l = 0, len1 = vertices.length; l < len1; l++) {
        b = vertices[l];
        // filter if hamming distance equal to 1
        c = a ^ b;
        if (0 !== c && 0 === (c & (c - 1))) {
          edge_indices.push([a, b]);
        }
      }
    }
    // map bits to arrays
    vertices = vertices.map(function(a) {
      return (function() {
        var results = [];
        for (var m = 0; 0 <= k ? m < k : m > k; 0 <= k ? m++ : m--){ results.push(m); }
        return results;
      }).apply(this).map(function(b, i) {
        if (0 === (a >> i & 1)) {
          return -1;
        } else {
          return 1;
        }
      });
    });
// get cell/face vertices
    for (i = m = 0, ref1 = k; (0 <= ref1 ? m <= ref1 : m >= ref1); i = 0 <= ref1 ? ++m : --m) {
      ref2 = [0, 1];
      for (o = 0, len2 = ref2.length; o < len2; o++) {
        fixed = ref2[o];
        cell_indices.push(vertices.filter(function(a) {
          return fixed === a[i];
        }));
      }
    }
    return [vertices, edge_indices, cell_indices];
  };

  render_rotating_cube = function(options) {
    var angle, canvas, canvas_height, canvas_width, ctx, dimensions, draw, edge_indices, f, get_rotator, interval, project, projection_distance, projection_fov, refresh, rotate, rotate_dimensions, rotation_speed, space, vertices;
    // object -> interval
    // repeatedly draw and rotate a cube on an html canvas.
    dimensions = options.dimensions || 3;
    // elements set to zero are not rotated
    rotate_dimensions = options.rotate_dimensions || [];
    // in milliseconds
    refresh = options.refresh || 20;
    // in radians
    rotation_speed = options.rotation_speed || 0.008;
    // in pixel
    canvas_width = options.canvas_width || 800;
    canvas_height = options.canvas_height || 400;
    projection_distance = 3;
    projection_fov = 400;
    get_rotator = function(space) {
      var rotators;
      // one rotation function per plane
      rotators = array_new(dimensions, 0).map(function(a, index) {
        var data, ia, ib;
        if (0 === rotate_dimensions[index]) {
          return function(a, angle) {
            return a;
          };
        }
        data = array_new(dimensions, 0);
        ia = (index + 1) % dimensions;
        ib = index;
        return function(a, angle) {
          var rotor;
          angle = angle + ((ia + 1) * 1000);
          // array number -> array
          data[ia] = Math.cos(angle);
          data[ib] = Math.sin(angle);
          // create a versorjs object
          rotor = space.Vec.apply(this, data);
          return space.Vec.apply(this, a).sp(rotor).toArray();
        };
      });
      return function(a, angle) {
        var f;
        // apply all rotation functions to the given point vector
        f = function(a, rotate) {
          return a && rotate(a, angle);
        };
        return rotators.reduce(f, a);
      };
    };
    project = function(a, width, height, fov, distance) {
      var factor, x, y;
      // perspective projection
      factor = fov / (distance + (a[2] || 1));
      x = a[0] * factor + width / 2;
      y = a[1] * factor + height / 2;
      return [x, y].concat(array_copy(a));
    };
    draw = function(ctx, vertices, edge_indices, rotate, angle) {
      var height, width;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      ctx.fillRect(0, 0, width, height);
      vertices = vertices.map(function(a) {
        return project(rotate(a, angle), width, height, projection_fov, projection_distance);
      });
      edge_indices.forEach(function(a, index) {
        var end, start;
        start = vertices[a[0]];
        end = vertices[a[1]];
        ctx.beginPath();
        ctx.moveTo(start[0], start[1]);
        ctx.lineTo(end[0], end[1]);
        ctx.closePath();
        return ctx.stroke();
      });
      return angle + rotation_speed;
    };
    canvas = document.getElementById("cube");
    if (!(canvas && canvas.getContext)) {
      return;
    }
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    ctx = canvas.getContext("2d");
    ctx.strokeStyle = "#8096bf";
    ctx.fillStyle = "#000";
    space = versor.create({
      metric: array_new(dimensions, 1)
    });
    rotate = get_rotator(space);
    angle = 0;
    [vertices, edge_indices] = k_cube_vectors(dimensions);
    // called repeatedly and updates angle
    f = function() {
      return angle = draw(ctx, vertices, edge_indices, rotate, angle);
    };
    interval = setInterval(f, refresh);
    return interval;
  };

  ui_controls = (function() {
    class ui_controls {
      label(text, content) {
        var label;
        return label = crel("label", text, content);
      }

      update() {
        var count, rot_dim;
        // start rendering with a new configuration
        this.options.dimensions = Math.max(1, false_if_nan(parseInt(this.dom.in.dim.value)) || this.options.dimensions);
        if (!this.warning_shown && 9 === this.options.dimensions) {
          count = 2 ** this.options.dimensions;
          alert("increasing dimensions can easily overload the browser. now continuing to create " + count + " vertices", "notice");
          this.warning_shown = true;
        }
        this.options.rotate_dimensions = this.dom.in.rot_dim.map(function(a) {
          if (a.checked) {
            return 1;
          } else {
            return 0;
          }
        });
        rot_dim = document.getElementById("rot_dim");
        rot_dim.innerHTML = "";
        this.dom.in.rot_dim = this.in_rot_dim_new();
        this.dom.in.rot_dim.forEach(function(a) {
          return rot_dim.appendChild(a);
        });
        this.options.rotation_speed = false_if_nan(parseFloat(this.dom.in.rot_speed.value)) || this.options.rotation_speed;
        this.cube_interval && clearInterval(this.cube_interval);
        return this.cube_interval = render_rotating_cube(this.options);
      }

      in_rot_dim_new() {
        var axes;
        // create a new array of checkboxes
        axes = binomial(this.options.dimensions, 2);
        return array_new(axes, 0).map((a, index) => {
          a = crel("input", {
            type: "checkbox",
            value: index
          });
          a.checked = !(this.options.rotate_dimensions[index] === 0);
          a.addEventListener("change", this.update);
          return a;
        });
      }

      constructor() {
        var container, dim, in_dim, in_rot_dim, in_rot_speed, rot_dim, rot_speed;
        this.update = this.update.bind(this);
        this.in_rot_dim_new = this.in_rot_dim_new.bind(this);
        // create input fields and container
        in_dim = crel("input", {
          type: "number",
          value: this.options.dimensions
        });
        in_rot_speed = crel("input", {
          type: "number",
          step: "0.001",
          value: this.options.rotation_speed
        });
        in_rot_dim = this.in_rot_dim_new();
        rot_dim = crel("div", this.label("rotate"), crel("span", {
          id: "rot_dim"
        }, in_rot_dim));
        rot_speed = this.label("speed", in_rot_speed);
        dim = this.label("dimensions", in_dim);
        this.dom.in = {
          dim: in_dim,
          rot_dim: in_rot_dim,
          rot_speed: in_rot_speed
        };
        [in_dim, in_rot_speed].forEach((a) => {
          return a.addEventListener("change", this.update);
        });
        container = crel("div", dim, rot_dim, rot_speed);
        document.getElementById("controls").appendChild(container);
        this.update();
      }

    };

    // creates the html for the controls and default options
    ui_controls.prototype.options = {
      dimensions: 4,
      rotate_dimensions: [1, 0, 1, 1],
      refresh: 20,
      rotation_speed: 0.005,
      canvas_width: 1000,
      canvas_height: 800
    };

    ui_controls.prototype.dom = {};

    ui_controls.prototype.warning_shown = false;

    return ui_controls;

  }).call(this);

  new ui_controls();

}).call(this);
