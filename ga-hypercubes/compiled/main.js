// Generated by CoffeeScript 2.5.1
(function() {
  // depends on https://github.com/weshoke/versor.js, https://github.com/KoryNunn/crel.
  // * the first part of the file defines helper routines
  // * the "cube" function is the main drawing function
  // * ui_controls is for the html controls form
  var array_copy, array_equals, array_includes_array, array_new, array_numeric_increment_le, cube, factorial, false_if_nan, k_cube_count, k_cubes_at_vertices_count, ui_controls, vector_diff, vector_diff_count;

  array_new = function(size, init) {
    var a;
    a = Array(size);
    if (init != null) {
      return a.fill(init);
    } else {
      return a;
    }
  };

  array_copy = function(a) {
    return a.slice();
  };

  array_equals = function(a, b) {
    var i;
    // note that arrays are passed by reference
    i = a.length;
    while (i -= 1) {
      if (!(a[i] === b[i])) {
        return false;
      }
    }
    return true;
  };

  array_includes_array = function(a, value) {
    // array array -> boolean
    return a.some(function(a) {
      return array_equals(a, value);
    });
  };

  array_numeric_increment_le = function(a, base) {
    var index;
    // increment array elements like digits of a number.
    // lower endian. 000, 100, 010, 110, 001, etc
    a = array_copy(a);
    index = 0;
    while (index < a.length) {
      if (a[index] < base) {
        a[index] += 1;
        break;
      } else {
        a[index] = 0;
        index += 1;
      }
    }
    return a;
  };

  factorial = function(n) {
    var result;
    result = 1;
    while (n >= 1) {
      result = result * n;
      n = n - 1;
    }
    return result;
  };

  false_if_nan = function(a) {
    if (isNaN(a)) {
      return false;
    } else {
      return a;
    }
  };

  vector_diff = function(a, b) {
    // array array -> array
    return a.map(function(a, index) {
      return a - b[index];
    });
  };

  vector_diff_count = function(a, b) {
    var diff, f;
    // count unequal elements
    diff = vector_diff(a, b);
    f = function(result, a) {
      if (0 === a) {
        return result;
      } else {
        return result + 1;
      }
    };
    return diff.reduce(f, 0);
  };

  k_cubes_at_vertices_count = function(k, dim) {
    return factorial(dim) / (factorial(k) * factorial(dim - k));
  };

  k_cube_count = function(k, dim) {
    return Math.pow(2, dim - k) * k_cubes_at_vertices_count(k, dim);
  };

  cube = function(options) {
    var angle, canvas, canvas_height, canvas_width, ctx, dimensions, draw, f, get_lines, get_rotator, get_vertices, interval, lines, project, refresh, rotate, rotate_dimensions, rotation_speed, space, vertices;
    // object -> interval
    // continuously draw and rotate a cube on an html canvas.
    dimensions = options.dimensions || 3;
    // elements set to zero are not rotated
    rotate_dimensions = options.rotate_dimensions || [];
    // in milliseconds
    refresh = options.refresh || 20;
    // in radians
    rotation_speed = options.rotation_speed || 0.002;
    // in pixel
    canvas_width = options.canvas_width || 800;
    canvas_height = options.canvas_height || 400;
    get_vertices = function() {
      var a, count, elements, index, result;
      // cube vertices are every distinct 2-tuple of -1 and 1
      result = [];
      count = 2 ** dimensions;
      elements = [-1, 1];
      a = array_new(dimensions, 0);
      result.push(a.map(function(a) {
        return elements[a];
      }));
      index = 0;
      while (index < count - 1) {
        a = array_numeric_increment_le(a, 1);
        result.push(a.map(function(a) {
          return elements[a];
        }));
        index += 1;
      }
      return result;
    };
    get_lines = function(vertices) {
      var a, b, ia, ib, is_adjacent, result;
      // produce all possible vertex pairings and filter
      result = [];
      ia = 0;
      while (ia < vertices.length) {
        ib = 0;
        while (ib < vertices.length) {
          if (ib !== ia) {
            a = vertices[ia];
            b = vertices[ib];
            is_adjacent = vector_diff_count(a, b) === 1;
            if (is_adjacent) {
              if (!array_includes_array(result, [ib, ia])) {
                result.push([ia, ib]);
              }
            }
          }
          ib += 1;
        }
        ia += 1;
      }
      return result;
    };
    get_rotator = function() {
      var rotators;
      // create one rotation function per plane
      rotators = array_new(dimensions, 0).map(function(a, index) {
        var data, ia, ib;
        // if 0 then return an identity function
        if (0 === rotate_dimensions[index]) {
          return function(a, angle) {
            return a;
          };
        }
        data = array_new(dimensions, 0);
        ia = (index + 1) % dimensions;
        ib = index;
        return function(a, angle) {
          var rotor;
          // array number -> array
          data[ia] = Math.cos(angle);
          data[ib] = Math.sin(angle);
          // create a versorjs object
          rotor = space.Vec.apply(this, data);
          return space.Vec.apply(this, a).sp(rotor).toArray();
        };
      });
      return function(a, angle) {
        var f;
        // apply all rotation functions to the given point vector
        f = function(a, rotate) {
          return a && rotate(a, angle);
        };
        return rotators.reduce(f, a);
      };
    };
    project = function(a, width, height, fov, distance) {
      var factor, x, y;
      // scale and project to simulate depth
      factor = fov / (distance + (a[2] || 1));
      x = a[0] * factor + width / 2;
      y = a[1] * factor + height / 2;
      return [x, y].concat(array_copy(a));
    };
    draw = function(ctx, vertices, lines, rotate, angle) {
      var height, v, width;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      ctx.fillRect(0, 0, width, height);
      // apply vertex transformations
      v = vertices.map(function(a) {
        a = rotate(a, angle);
        return project(a, width, height, 400, 5);
      });
      // draw edges
      lines.forEach(function(a, index) {
        var end, start;
        start = a[0];
        end = a[1];
        ctx.strokeStyle = "hsl(298, " + (40 + (index / lines.length) * 60) + "%, 61%)";
        ctx.beginPath();
        ctx.moveTo(v[start][0], v[start][1]);
        ctx.lineTo(v[end][0], v[end][1]);
        ctx.closePath();
        return ctx.stroke();
      });
      return angle + rotation_speed;
    };
    canvas = document.getElementById("cube");
    if (!(canvas && canvas.getContext)) {
      return;
    }
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    ctx = canvas.getContext("2d");
    ctx.strokeStyle = "rgb(255,55,255)";
    ctx.fillStyle = "rgb(0,0,0)";
    vertices = get_vertices(dimensions);
    lines = get_lines(vertices);
    space = versor.create({
      metric: array_new(dimensions, 1)
    });
    rotate = get_rotator();
    angle = 0;
    // called repeatedly and updates angle
    f = function() {
      return angle = draw(ctx, vertices, lines, rotate, angle);
    };
    interval = setInterval(f, refresh);
    return interval;
  };

  ui_controls = (function() {
    class ui_controls {
      label(text, content) {
        var label;
        return label = crel("label", text, content);
      }

      update() {
        var count, rot_dim;
        this.options.dimensions = Math.max(1, false_if_nan(parseInt(this.dom.in.dim.value)) || this.options.dimensions);
        if (!this.warning_shown && 9 === this.options.dimensions) {
          count = 2 ** this.options.dimensions;
          alert("increasing dimensions can easily overload the browser. now continuing to create " + count + " vertices", "notice");
          this.warning_shown = true;
        }
        this.options.rotate_dimensions = this.dom.in.rot_dim.map(function(a) {
          if (a.checked) {
            return 1;
          } else {
            return 0;
          }
        });
        rot_dim = document.getElementById("rot_dim");
        rot_dim.innerHTML = "";
        this.dom.in.rot_dim = this.in_rot_dim_new();
        this.dom.in.rot_dim.forEach(function(a) {
          return rot_dim.appendChild(a);
        });
        this.options.rotation_speed = false_if_nan(parseFloat(this.dom.in.rot_speed.value)) || this.options.rotation_speed;
        this.cube_interval && clearInterval(this.cube_interval);
        return this.cube_interval = cube(this.options);
      }

      in_rot_dim_new() {
        // create a new array of checkboxes
        return array_new(this.options.dimensions, 0).map((a, index) => {
          a = crel("input", {
            type: "checkbox",
            value: index
          });
          a.checked = !(this.options.rotate_dimensions[index] === 0);
          a.addEventListener("change", this.update);
          return a;
        });
      }

      constructor() {
        var container, dim, in_dim, in_rot_dim, in_rot_speed, rot_dim, rot_speed;
        this.update = this.update.bind(this);
        this.in_rot_dim_new = this.in_rot_dim_new.bind(this);
        // create input fields and container
        in_dim = crel("input", {
          type: "number",
          value: this.options.dimensions
        });
        in_rot_speed = crel("input", {
          type: "number",
          step: "0.001",
          value: this.options.rotation_speed
        });
        in_rot_dim = this.in_rot_dim_new();
        rot_dim = crel("div", this.label("rotate"), crel("span", {
          id: "rot_dim"
        }, in_rot_dim));
        rot_speed = this.label("speed", in_rot_speed);
        dim = this.label("dimensions", in_dim);
        this.dom.in = {
          dim: in_dim,
          rot_dim: in_rot_dim,
          rot_speed: in_rot_speed
        };
        [in_dim, in_rot_speed].forEach((a) => {
          return a.addEventListener("change", this.update);
        });
        container = crel("div", dim, rot_dim, rot_speed);
        document.getElementById("controls").appendChild(container);
        this.update();
      }

    };

    // the html for the controls and default options
    ui_controls.prototype.options = {
      dimensions: 4,
      rotate_dimensions: [1, 0, 0, 1],
      refresh: 20,
      rotation_speed: 0.01,
      canvas_width: 1000,
      canvas_height: 800
    };

    ui_controls.prototype.dom = {};

    ui_controls.prototype.warning_shown = false;

    return ui_controls;

  }).call(this);

  new ui_controls();

}).call(this);
