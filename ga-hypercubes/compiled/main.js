// Generated by CoffeeScript 1.12.7
(function() {
  var array_copy, array_equals, array_includes_array, array_new, array_numeric_increment_le, cube, factorial, k_cube_count, k_cubes_at_vertices_count, vector_diff, vector_diff_count;

  array_new = function(size, init) {
    return Array(size).fill(init);
  };

  array_copy = function(a) {
    return a.slice();
  };

  array_equals = function(a, b) {
    var i;
    i = a.length;
    while (i -= 1) {
      if (!(a[i] === b[i])) {
        return false;
      }
    }
    return true;
  };

  array_includes_array = function(a, value) {
    return a.some(function(a) {
      return array_equals(a, value);
    });
  };

  array_numeric_increment_le = function(a, base) {
    var index;
    a = array_copy(a);
    index = 0;
    while (index < a.length) {
      if (a[index] < base) {
        a[index] += 1;
        break;
      } else {
        a[index] = 0;
        index += 1;
      }
    }
    return a;
  };

  factorial = function(n) {
    var result;
    result = 1;
    while (n >= 1) {
      result = result * n;
      n = n - 1;
    }
    return result;
  };

  vector_diff = function(a, b) {
    return a.map(function(a, index) {
      return a - b[index];
    });
  };

  vector_diff_count = function(a, b) {
    var diff, f;
    diff = vector_diff(a, b);
    f = function(result, a) {
      if (0 === a) {
        return result;
      } else {
        return result + 1;
      }
    };
    return diff.reduce(f, 0);
  };

  k_cubes_at_vertices_count = function(k, dim) {
    return factorial(dim) / (factorial(k) * factorial(dim - k));
  };

  k_cube_count = function(k, dim) {
    return Math.pow(2, dim - k) * k_cubes_at_vertices_count(k, dim);
  };

  cube = function(options) {
    var angle, canvas, canvas_height, canvas_width, ctx, dimensions, draw, f, get_lines, get_rotator, get_vertices, lines, project, refresh, rotate, rotate_dimensions, rotation_speed, space, vertices;
    dimensions = options.dimensions || 3;
    rotate_dimensions = options.rotate_dimensions || [];
    refresh = options.refresh || 20;
    rotation_speed = options.rotation_speed || 0.002;
    canvas_width = options.canvas_width || 800;
    canvas_height = options.canvas_height || 400;
    get_vertices = function() {
      var a, count, elements, index, result;
      result = [];
      count = Math.pow(2, dimensions);
      elements = [-1, 1];
      a = array_new(dimensions, 0);
      result.push(a.map(function(a) {
        return elements[a];
      }));
      index = 0;
      while (index < count - 1) {
        a = array_numeric_increment_le(a, 1);
        result.push(a.map(function(a) {
          return elements[a];
        }));
        index += 1;
      }
      return result;
    };
    get_lines = function(vertices) {
      var a, b, ia, ib, is_adjacent, result;
      result = [];
      ia = 0;
      while (ia < vertices.length) {
        ib = 0;
        while (ib < vertices.length) {
          if (ib !== ia) {
            a = vertices[ia];
            b = vertices[ib];
            is_adjacent = vector_diff_count(a, b) === 1;
            if (is_adjacent) {
              if (!array_includes_array(result, [ib, ia])) {
                result.push([ia, ib]);
              }
            }
          }
          ib += 1;
        }
        ia += 1;
      }
      return result;
    };
    get_rotator = function() {
      var rotators;
      rotators = array_new(dimensions, 0).map(function(a, index) {
        var data, ia, ib;
        if (0 === rotate_dimensions[index]) {
          return function(a, angle) {
            return a;
          };
        }
        data = array_new(dimensions, 0);
        ia = (index + 1) % dimensions;
        ib = index;
        return function(a, angle) {
          var rotor;
          data[ia] = Math.cos(angle);
          data[ib] = Math.sin(angle);
          rotor = space.Vec.apply(this, data);
          return space.Vec.apply(this, a).sp(rotor).toArray();
        };
      });
      return function(a, angle) {
        var f;
        f = function(a, rotate) {
          return a && rotate(a, angle);
        };
        return rotators.reduce(f, a);
      };
    };
    project = function(a, width, height, fov, distance) {
      var factor, x, y;
      factor = fov / (distance + (a[2] || 1));
      x = a[0] * factor + width / 2;
      y = a[1] * factor + height / 2;
      return [x, y].concat(array_copy(a));
    };
    draw = function(ctx, vertices, lines, rotate, angle) {
      var height, v, width;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      ctx.fillRect(0, 0, width, height);
      v = vertices.map(function(a) {
        a = rotate(a, angle);
        return project(a, width, height, 400, 5);
      });
      lines.forEach(function(a) {
        var end, start;
        ctx.beginPath();
        start = a[0];
        end = a[1];
        ctx.moveTo(v[start][0], v[start][1]);
        ctx.lineTo(v[end][0], v[end][1]);
        ctx.closePath();
        return ctx.stroke();
      });
      return angle + rotation_speed;
    };
    canvas = document.getElementById("cube");
    if (!(canvas && canvas.getContext)) {
      return;
    }
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    ctx = canvas.getContext("2d");
    ctx.strokeStyle = "rgb(255,55,255)";
    ctx.fillStyle = "rgb(0,0,0)";
    vertices = get_vertices(dimensions);
    lines = get_lines(vertices);
    space = versor.create({
      metric: array_new(dimensions, 1)
    });
    rotate = get_rotator();
    angle = 0;
    f = function() {
      return angle = draw(ctx, vertices, lines, rotate, angle);
    };
    return setInterval(f, refresh);
  };

  cube({
    dimensions: 4,
    rotate_dimensions: [0, 1, 1, 0, 1],
    refresh: 20,
    rotation_speed: 0.004,
    canvas_width: 1000,
    canvas_height: 800
  });

}).call(this);
