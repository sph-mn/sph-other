// Generated by CoffeeScript 1.12.7
(function() {
  var array_copy, array_equals, array_includes_array, array_new, array_numeric_increment_le, cube, factorial, false_if_nan, k_cube_count, k_cubes_at_vertices_count, ui_controls, vector_diff, vector_diff_count,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  array_new = function(size, init) {
    var a;
    a = Array(size);
    if (init != null) {
      return a.fill(init);
    } else {
      return a;
    }
  };

  array_copy = function(a) {
    return a.slice();
  };

  array_equals = function(a, b) {
    var i;
    i = a.length;
    while (i -= 1) {
      if (!(a[i] === b[i])) {
        return false;
      }
    }
    return true;
  };

  array_includes_array = function(a, value) {
    return a.some(function(a) {
      return array_equals(a, value);
    });
  };

  array_numeric_increment_le = function(a, base) {
    var index;
    a = array_copy(a);
    index = 0;
    while (index < a.length) {
      if (a[index] < base) {
        a[index] += 1;
        break;
      } else {
        a[index] = 0;
        index += 1;
      }
    }
    return a;
  };

  factorial = function(n) {
    var result;
    result = 1;
    while (n >= 1) {
      result = result * n;
      n = n - 1;
    }
    return result;
  };

  false_if_nan = function(a) {
    if (isNaN(a)) {
      return false;
    } else {
      return a;
    }
  };

  vector_diff = function(a, b) {
    return a.map(function(a, index) {
      return a - b[index];
    });
  };

  vector_diff_count = function(a, b) {
    var diff, f;
    diff = vector_diff(a, b);
    f = function(result, a) {
      if (0 === a) {
        return result;
      } else {
        return result + 1;
      }
    };
    return diff.reduce(f, 0);
  };

  k_cubes_at_vertices_count = function(k, dim) {
    return factorial(dim) / (factorial(k) * factorial(dim - k));
  };

  k_cube_count = function(k, dim) {
    return Math.pow(2, dim - k) * k_cubes_at_vertices_count(k, dim);
  };

  cube = function(options) {
    var angle, canvas, canvas_height, canvas_width, ctx, dimensions, draw, f, get_lines, get_rotator, get_vertices, interval, lines, project, refresh, rotate, rotate_dimensions, rotation_speed, space, vertices;
    dimensions = options.dimensions || 3;
    rotate_dimensions = options.rotate_dimensions || [];
    refresh = options.refresh || 20;
    rotation_speed = options.rotation_speed || 0.002;
    canvas_width = options.canvas_width || 800;
    canvas_height = options.canvas_height || 400;
    get_vertices = function() {
      var a, count, elements, index, result;
      result = [];
      count = Math.pow(2, dimensions);
      elements = [-1, 1];
      a = array_new(dimensions, 0);
      result.push(a.map(function(a) {
        return elements[a];
      }));
      index = 0;
      while (index < count - 1) {
        a = array_numeric_increment_le(a, 1);
        result.push(a.map(function(a) {
          return elements[a];
        }));
        index += 1;
      }
      return result;
    };
    get_lines = function(vertices) {
      var a, b, ia, ib, is_adjacent, result;
      result = [];
      ia = 0;
      while (ia < vertices.length) {
        ib = 0;
        while (ib < vertices.length) {
          if (ib !== ia) {
            a = vertices[ia];
            b = vertices[ib];
            is_adjacent = vector_diff_count(a, b) === 1;
            if (is_adjacent) {
              if (!array_includes_array(result, [ib, ia])) {
                result.push([ia, ib]);
              }
            }
          }
          ib += 1;
        }
        ia += 1;
      }
      return result;
    };
    get_rotator = function() {
      var rotators;
      rotators = array_new(dimensions, 0).map(function(a, index) {
        var data, ia, ib;
        if (0 === rotate_dimensions[index]) {
          return function(a, angle) {
            return a;
          };
        }
        data = array_new(dimensions, 0);
        ia = (index + 1) % dimensions;
        ib = index;
        return function(a, angle) {
          var rotor;
          data[ia] = Math.cos(angle);
          data[ib] = Math.sin(angle);
          rotor = space.Vec.apply(this, data);
          return space.Vec.apply(this, a).sp(rotor).toArray();
        };
      });
      return function(a, angle) {
        var f;
        f = function(a, rotate) {
          return a && rotate(a, angle);
        };
        return rotators.reduce(f, a);
      };
    };
    project = function(a, width, height, fov, distance) {
      var factor, x, y;
      factor = fov / (distance + (a[2] || 1));
      x = a[0] * factor + width / 2;
      y = a[1] * factor + height / 2;
      return [x, y].concat(array_copy(a));
    };
    draw = function(ctx, vertices, lines, rotate, angle) {
      var height, v, width;
      width = ctx.canvas.width;
      height = ctx.canvas.height;
      ctx.fillRect(0, 0, width, height);
      v = vertices.map(function(a) {
        a = rotate(a, angle);
        return project(a, width, height, 400, 5);
      });
      lines.forEach(function(a) {
        var end, start;
        ctx.beginPath();
        start = a[0];
        end = a[1];
        ctx.moveTo(v[start][0], v[start][1]);
        ctx.lineTo(v[end][0], v[end][1]);
        ctx.closePath();
        return ctx.stroke();
      });
      return angle + rotation_speed;
    };
    canvas = document.getElementById("cube");
    if (!(canvas && canvas.getContext)) {
      return;
    }
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    ctx = canvas.getContext("2d");
    ctx.strokeStyle = "rgb(255,55,255)";
    ctx.fillStyle = "rgb(0,0,0)";
    vertices = get_vertices(dimensions);
    lines = get_lines(vertices);
    space = versor.create({
      metric: array_new(dimensions, 1)
    });
    rotate = get_rotator();
    angle = 0;
    f = function() {
      return angle = draw(ctx, vertices, lines, rotate, angle);
    };
    interval = setInterval(f, refresh);
    return interval;
  };

  ui_controls = (function() {
    ui_controls.prototype.options = {
      dimensions: 4,
      rotate_dimensions: [0, 1, 1, 0, 1],
      refresh: 20,
      rotation_speed: 0.004,
      canvas_width: 1000,
      canvas_height: 800
    };

    ui_controls.prototype.dom = {};

    ui_controls.prototype.label = function(text, content) {
      var label;
      return label = crel("label", text, content);
    };

    ui_controls.prototype.warning_shown = false;

    ui_controls.prototype.update = function() {
      var count, rot_dim;
      this.options.dimensions = Math.max(1, false_if_nan(parseInt(this.dom["in"].dim.value)) || this.options.dimensions);
      if (!this.warning_shown && 9 === this.options.dimensions) {
        count = Math.pow(2, this.options.dimensions);
        alert("one-time warning: with many dimensions this can easily freeze the browser tab. continuing to create " + count + " vertices", "warning");
        this.warning_shown = true;
      }
      this.options.rotate_dimensions = this.dom["in"].rot_dim.map(function(a) {
        if (a.checked) {
          return 1;
        } else {
          return 0;
        }
      });
      rot_dim = document.getElementById("rot_dim");
      rot_dim.innerHTML = "";
      this.dom["in"].rot_dim = this.in_rot_dim_new();
      this.dom["in"].rot_dim.forEach(function(a) {
        return rot_dim.appendChild(a);
      });
      this.options.rotation_speed = false_if_nan(parseFloat(this.dom["in"].rot_speed.value)) || this.options.rotation_speed;
      this.cube_interval && clearInterval(this.cube_interval);
      return this.cube_interval = cube(this.options);
    };

    ui_controls.prototype.in_rot_dim_new = function() {
      return array_new(this.options.dimensions, 0).map((function(_this) {
        return function(a, index) {
          a = crel("input", {
            type: "checkbox",
            value: index
          });
          a.checked = !(_this.options.rotate_dimensions[index] === 0);
          a.addEventListener("change", _this.update);
          return a;
        };
      })(this));
    };

    function ui_controls() {
      this.in_rot_dim_new = bind(this.in_rot_dim_new, this);
      this.update = bind(this.update, this);
      var container, dim, in_dim, in_rot_dim, in_rot_speed, rot_dim, rot_speed;
      in_dim = crel("input", {
        type: "number",
        value: this.options.dimensions
      });
      in_rot_speed = crel("input", {
        type: "number",
        step: "0.001",
        value: this.options.rotation_speed
      });
      in_rot_dim = this.in_rot_dim_new();
      rot_dim = crel("div", this.label("rotate"), crel("span", {
        id: "rot_dim"
      }, in_rot_dim));
      rot_speed = this.label("speed", in_rot_speed);
      dim = this.label("dimensions", in_dim);
      this.dom["in"] = {
        dim: in_dim,
        rot_dim: in_rot_dim,
        rot_speed: in_rot_speed
      };
      [in_dim, in_rot_speed].forEach((function(_this) {
        return function(a) {
          return a.addEventListener("change", _this.update);
        };
      })(this));
      container = crel("div", dim, rot_dim, rot_speed);
      document.getElementById("controls").appendChild(container);
      this.update();
    }

    return ui_controls;

  })();

  new ui_controls;

}).call(this);
