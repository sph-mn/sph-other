// Generated by CoffeeScript 2.7.0
var adjust_color_brightness, any_square, array_sum, available_colors, color_to_string, create_versor_space, fragment_shader_defaults, fragment_shader_solid_source, fragment_shader_wireframe_source, generate_axis_combinations, get_cell_indices, get_projector, get_rotator, gl_initialize, group_n_cells, indices_sorter, random_color, render_rotating_cube, sort_edges_cyclically, triangulate_squares, vertex_shader_source,
  indexOf = [].indexOf;

random_color = function() {
  return [Math.random(), Math.random(), Math.random()];
};

color_to_string = function(a) {
  return `rgb(${a[0]}, ${a[1]}, ${a[2]})`;
};

available_colors = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function(a) {
  return random_color();
});

adjust_color_brightness = function(a, factor) {
  return a.map(function(a) {
    return Math.min(255, Math.max(0, a * factor));
  });
};

array_sum = function(a) {
  return a.reduce((function(a, b) {
    return a + b;
  }), 0);
};

any_square = function(cells, f) {
  // array {array -> any} -> any
  // apply Array.find only on 2-cells and return the first truthy result
  if (4 === cells.length && 2 === cells[0].length && Number.isInteger(cells[0][0])) {
    return f(cells);
  } else {
    return any(cells, function(a) {
      return any_square(a, f);
    });
  }
};

sort_edges_cyclically = function(cells) {
  var i, is_adjacent, j, link, ref;
  // sort edge vertices to form a continuous line
  is_adjacent = function(a, b) {
    return a.some(function(a) {
      return indexOf.call(b, a) >= 0;
    });
  };
  cells = sort_by_predicate(cells, is_adjacent);
  link = cells[0].find(function(a) {
    return indexOf.call(cells[1], a) >= 0;
  });
  if (link !== cells[0][1]) {
    array_swap(cells[0], 0, 1);
  }
  for (i = j = 1, ref = cells.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
    if (cells[i - 1][1] !== cells[i][0]) {
      array_swap(cells[i], 1, 0);
    }
  }
  return cells;
};

group_n_cells = function(vertices, indices, n, k, cell_length) {
  var cell_indices, cell_vertices, fixed, fixed_combinations, i, j, key, l, len, len1, new_cell_indices;
  fixed_combinations = get_bit_combinations(n, k);
  cell_indices = [];
  for (j = 0, len = fixed_combinations.length; j < len; j++) {
    fixed = fixed_combinations[j];
    cell_vertices = {};
    for (l = 0, len1 = indices.length; l < len1; l++) {
      i = indices[l];
      key = fixed & vertices[i];
      if (cell_vertices[key]) {
        cell_vertices[key].push(i);
      } else {
        cell_vertices[key] = [i];
      }
    }
    new_cell_indices = Object.values(cell_vertices).filter(function(a) {
      return cell_length === a.length;
    });
    cell_indices = cell_indices.concat(new_cell_indices);
  }
  return cell_indices;
};

get_cell_indices = function(vertices, n) {
  var ref, subcells;
  // integer -> array
  // get edges grouped by nested cells
  subcells = function(indices, k) {
    var a, j, len, results;
    if (!(k < n)) {
      return indices;
    }
    indices = group_n_cells(vertices, indices, n, k, 2 ** (n - k));
    if (k === n - 1) {
      indices = sort_edges_cyclically(indices);
    }
    results = [];
    for (j = 0, len = indices.length; j < len; j++) {
      a = indices[j];
      results.push(subcells(a, k + 1));
    }
    return results;
  };
  return subcells((function() {
    var results = [];
    for (var j = 0, ref = vertices.length; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this), 1);
};

vertex_shader_source = `#version 300 es
precision highp float;
in vec4 position;
void main() {
  gl_Position = position;
}`;

fragment_shader_defaults = `#version 300 es
precision highp float;
out vec4 fragment_color;`;

fragment_shader_wireframe_source = fragment_shader_defaults + `void main() {
  fragment_color = vec4(1.0, 0.0, 0.0, 1.0);
}`;

fragment_shader_solid_source = fragment_shader_defaults + `void main() {
  fragment_color = vec4(1.0, 1.0, 1.0, 1.0);
}`;

gl_initialize = function(canvas) {
  var fragment_shader_solid, fragment_shader_wireframe, gl, position_attribute_location, program_solid, program_wireframe, vertex_shader;
  gl = canvas.getContext("webgl2");
  if (!gl) {
    alert("unable to initialize webgl2. your browser may not support it.");
    return;
  }
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.clearColor(0, 0, 0, 1);
  gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
  vertex_shader = gl_create_shader(gl, "VERTEX_SHADER", vertex_shader_source);
  fragment_shader_wireframe = gl_create_shader(gl, "FRAGMENT_SHADER", fragment_shader_wireframe_source);
  fragment_shader_solid = gl_create_shader(gl, "FRAGMENT_SHADER", fragment_shader_solid_source);
  program_wireframe = gl_create_program(gl, vertex_shader, fragment_shader_wireframe);
  program_solid = gl_create_program(gl, vertex_shader, fragment_shader_solid);
  // link position variable to array_buffer
  position_attribute_location = gl.getAttribLocation(program_wireframe, 'position');
  gl.enableVertexAttribArray(position_attribute_location);
  gl.vertexAttribPointer(position_attribute_location, 3, gl.FLOAT, false, 0, 0);
  gl.enable(gl.CULL_FACE);
  return gl;
};

get_projector = function(space, options) {
  var angle, d, eo, normal, rotors, scalar_part, vector_part;
  // perspective projection
  // r1 = e ** ((angle / 2) * n * eo) = cos(angle / 2) + sin(angle / 2) * n * eo
  // r2 = e ** ((1 / (2 * d)) * n * eo) = 1 + ep 1 / (2 * d) * n, eo
  rotors = [];
  //# reflection rotor r1
  angle = options.projection_angle;
  normal = space.e1(1);
  eo = space.eo(1);
  scalar_part = space.s(Math.cos(angle / 2));
  vector_part = normal.gp(eo).gp(space.s(Math.sin(angle / 2)));
  rotors.push(scalar_part.add(vector_part));
  //# inversion rotor r2
  d = options.projection_distance;
  scalar_part = space.s(1);
  vector_part = normal.op(space.s(1 / (2 * d)).gp(normal), eo);
  rotors.push(scalar_part.add(vector_part));
  return function(a) {
    return rotors.reduce((function(a, b) {
      return a.sp(b);
    }), a);
  };
};

get_rotator = function(space, options) {
  var a, bivector_magnitude, i, rotor_data, rotors;
  // object object -> {versor_object:vertex -> versor_object:vertex}
  // rotation
  // R = cos(angle / 2) + B * sin(angle / 2)
  bivector_magnitude = Math.sin(options.rotation_speed / 2);
  rotor_data = Array(options.dimensions + 1);
  rotor_data[0] = Math.cos(options.rotation_speed / 2);
  return rotors = (function() {
    var j, len, ref, results;
    ref = options.rotate_dimensions;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      a = ref[i];
      if (!a) {
        continue;
      }
      rotor_data = rotor_data.fill(0, 1);
      rotor_data[i + 1] = bivector_magnitude;
      results.push(space.new("rotor", rotor_data));
    }
    return results;
  })();
};

generate_axis_combinations = function(dimension) {
  var combinations, generate_combinations;
  combinations = [];
  generate_combinations = function(prefix, start, depth) {
    var i, j, ref, ref1, results;
    if (depth) {
      results = [];
      for (i = j = ref = start, ref1 = dimension; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
        results.push(generate_combinations(prefix + (i + 1), i + 1, depth - 1));
      }
      return results;
    } else {
      return combinations.push(prefix);
    }
  };
  generate_combinations("e", 0, 2);
  return combinations;
};

create_versor_space = function(n) {
  var en, ref, space, types;
  en = (function() {
    var results = [];
    for (var j = 1, ref = n + 2; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this);
  types = [
    {
      name: "rotor",
      bases: ["s"].concat(generate_axis_combinations(n))
    },
    {
      name: "point",
      bases: en.map(function(a) {
        return `e${a}`;
      })
    },
    {
      name: "pseudoscalar",
      bases: ["e" + en.join("")]
    },
    {
      name: "eo",
      bases: ["e" + (n + 1)]
    },
    {
      name: "ei",
      bases: ["e" + (n + 2)]
    }
  ];
  space = versor.create({
    metric: Array(n).fill(1).concat([1, -1]),
    conformal: true,
    types: types
  });
  space.new = function(type, values) {
    var bases_length;
    // allows less values to be passed and sets the rest to zero, which versor.js does not do by default
    bases_length = this.types[type].bases.length;
    if (bases_length > values.length) {
      values = values.concat(Array(bases_length - values.length).fill(0));
    }
    return this[type].apply(this, values);
  };
  space.point_from_cartesian = function(a) {
    var eic;
    eic = 0.5 * array_sum(a.map(function(a) {
      return a * a;
    }));
    return this.new("point", a.concat([1, eic]));
  };
  space.point_to_cartesian = function(a) {
    return a.toArray().slice(0, n);
  };
  return space;
};

triangulate_squares = function(indices, n) {
  return array_map_depth(indices, n - 3, function(a) {
    return [[a[0][0], a[0][1], a[2][1]], [a[1][0], a[1][1], a[2][1]]];
  });
};

indices_sorter = function(space, n, vertices) {
  var pss;
  pss = space.pseudoscalar(1);
  return function(indices) {
    // sort edges counter clockwise.
    // assumes that edges are already sorted cyclically
    return array_map_depth(indices, n - 2, function(a) {
      var normal, orientation, p1, p2, p3;
      [p3, p2, p1] = a.map(function(a) {
        return vertices[a];
      });
      //a = [a[2], a[0], a[1]]
      //points = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
      //points = [[0, 1, 0], [1, 0, 0], [0, 0, 1]]
      //[p1, p2, p3] = points.map (a) -> space.point_from_cartesian a
      normal = p2.sub(p1).op(p3.sub(p1));
      console.log(normal.toArray());
      orientation = normal.ip(space.e5(1));
      //console.log normal, orientation
      if (0 < orientation) {
        return a;
      } else {
        return [a[0], a[2], a[1]];
      }
    });
  };
};

render_rotating_cube = function(options) {
  var draw, final_vertices, gl, indices, n, on_frame, previous_time, projector, ref, rotator, sorter, space, vertices;
  // object -> interval
  // repeatedly draw and rotate a cube.
  // various vector formats are used:
  // - cell finding: integer bitvectors
  // - transformations: versor.js vectors
  // - vertex sorting: integer arrays
  // - webgl: float32arrays
  gl = gl_initialize(options.canvas);
  n = options.dimensions;
  space = create_versor_space(n);
  rotator = get_rotator(space, options);
  projector = get_projector(space, options);
  vertices = (function() {
    var results = [];
    for (var j = 0, ref = 2 ** n; 0 <= ref ? j < ref : j > ref; 0 <= ref ? j++ : j--){ results.push(j); }
    return results;
  }).apply(this);
  indices = get_cell_indices(vertices, n);
  vertices = vertices.map(function(a) {
    return space.point_from_cartesian(bits_to_array(a, n));
  });
  indices = triangulate_squares(indices, n);
  sorter = indices_sorter(space, n, vertices);
  sorter(indices);
  return;
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  final_vertices = new Float32Array(vertices.length);
  draw = function() {
    var i, j, ref1;
    for (i = j = 0, ref1 = vertices.length; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
      vertices[i] = transform(vertices[i]);
      final_vertices[i] = project(vertices[i]);
    }
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
    return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  };
  //gl.useProgram program_wireframe
  //gl.drawElements gl.LINES, indices.length, gl.UNSIGNED_SHORT, 0
  //if false
  //  gl.useProgram program_solid
  //  gl.drawElements gl.TRIANGLES, faces.length, gl.UNSIGNED_SHORT, 0
  draw();
  options.canvas.addEventListener("click", function(event) {
    return draw();
  });
  previous_time = -options.refresh;
  return;
  on_frame = function(time) {
    if (options.refresh <= time - previous_time) {
      previous_time = time;
      draw();
    }
    return requestAnimationFrame(on_frame);
  };
  return requestAnimationFrame(on_frame);
};
