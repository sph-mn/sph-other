// Generated by CoffeeScript 2.7.0
(function() {
  // depends on https://github.com/weshoke/versor.js, https://github.com/KoryNunn/crel.
  // * the first part of the file defines helper routines
  // * the render_rotating_cube function is the main drawing loop function
  // * ui_controls is for the html controls form
  var adjust_color_brightness, any, any_square, array_copy, array_map_leafs, array_swap, available_colors, binomial, bits_to_array, color_to_string, create_canvas_gradient, edge_equal, false_if_nan, get_bit_combinations, get_n_cube_cells, group_n_cells, intersection, line_midpoint, p, perspective_project, random_color, render_rotating_cube, sort_by_predicate, sort_cells_by_edges, ui_controls, vertex_distance,
    indexOf = [].indexOf;

  array_copy = function(a) {
    return a.slice();
  };

  false_if_nan = function(a) {
    if (isNaN(a)) {
      return false;
    } else {
      return a;
    }
  };

  binomial = function(n, k) {
    // binomial coefficient (n choose k)
    if (k === 0 || k === n) {
      return 1;
    } else {
      return (n * binomial(n - 1, k - 1)) / k;
    }
  };

  p = function(a) {
    return console.log(JSON.stringify(a, null, 2));
  };

  get_bit_combinations = function(n, k) {
    var a, b, c, result;
    // generate all k-combinations of a set of size n as binary bitvectors.
    // algorithm: gospers hack
    result = [];
    a = (1 << k) - 1;
    while (a < (1 << n)) {
      result.push(a);
      b = a & -a;
      c = a + b;
      a = (((c ^ a) >> 2) / b) | c;
    }
    return result;
  };

  group_n_cells = function(vertices, n, k) {
    var a, cell_length, cell_vertices, cells, fixed, fixed_combinations, key, l, len, len1, m, new_cells;
    fixed_combinations = get_bit_combinations(n, k);
    cell_length = 2 ** (n - k);
    cells = [];
    for (l = 0, len = fixed_combinations.length; l < len; l++) {
      fixed = fixed_combinations[l];
      cell_vertices = {};
      for (m = 0, len1 = vertices.length; m < len1; m++) {
        a = vertices[m];
        key = fixed & a;
        if (cell_vertices[key]) {
          cell_vertices[key].push(a);
        } else {
          cell_vertices[key] = [a];
        }
      }
      new_cells = Object.values(cell_vertices).filter(function(a) {
        return cell_length === a.length;
      });
      cells = cells.concat(new_cells);
    }
    return cells;
  };

  intersection = function(a, b, min, includes) {
    var c, included, l, len;
    // array array integer {any any -> boolean} -> array
    // return the shared elements if at least "min" number of elements are shared.
    // "includes" is a custom comparison function.
    if (!includes) {
      includes = function(a, b) {
        return a.includes(b);
      };
    }
    included = [];
    for (l = 0, len = a.length; l < len; l++) {
      c = a[l];
      if (!includes(b, c)) {
        continue;
      }
      included.push(c);
      if (1 === min) {
        return included;
      }
      min -= 1;
    }
    return false;
  };

  array_swap = function(a, i, j) {
    var b;
    // array integer integer -> unspecified
    b = a[i];
    a[i] = a[j];
    return a[j] = b;
  };

  sort_by_predicate = function(a, predicate) {
    var adjacent, b, i, l, len, match_result, next_index, previous, sorted;
    // array {any any -> 0/1/2} -> array
    // 0: no-match, 1: acceptable, 2: optimal
    sorted = [a[0]];
    a = a.slice(1);
    while (a.length > 0) {
      previous = sorted[sorted.length - 1];
      next_index = 0;
      adjacent = null;
      for (i = l = 0, len = a.length; l < len; i = ++l) {
        b = a[i];
        match_result = predicate(previous, b);
        if (match_result) {
          next_index = i;
          if (2 === match_result) {
            break;
          }
        }
      }
      sorted.push(a[next_index]);
      a.splice(next_index, 1);
    }
    return sorted;
  };

  any = function(a, f) {
    var b, c, l, len;
// array {any -> any} -> any
// like Array.some but returns the truthy result
    for (l = 0, len = a.length; l < len; l++) {
      b = a[l];
      c = f(b);
      if (c) {
        return c;
      }
    }
    return false;
  };

  any_square = function(cells, f) {
    // array {array -> any} -> any
    // apply Array.find only on 2-cells and return the first truthy result
    if (4 === cells.length && 2 === cells[0].length && Number.isInteger(cells[0][0])) {
      return f(cells);
    } else {
      return any(cells, function(a) {
        return any_square(a, f);
      });
    }
  };

  edge_equal = function(a, b) {
    return (a[0] === b[0] && a[1] === b[1]) || (a[0] === b[1] && a[1] === b[0]);
  };

  sort_cells_by_edges = function(cells, n, k, cell_length) {
    var i, includes_edge, is_adjacent, is_adjacent_parallel, l, link, max_shared_edges, ref;
    // array integer integer integer -> array
    if (2 === cell_length) {
      // sort edge vertices to form a continuous line
      is_adjacent = function(a, b) {
        return a.some(function(a) {
          return indexOf.call(b, a) >= 0;
        });
      };
      cells = sort_by_predicate(cells, is_adjacent);
      link = cells[0].find(function(a) {
        return indexOf.call(cells[1], a) >= 0;
      });
      if (link !== cells[0][1]) {
        array_swap(cells[0], 0, 1);
      }
      for (i = l = 1, ref = cells.length; (1 <= ref ? l < ref : l > ref); i = 1 <= ref ? ++l : --l) {
        if (cells[i - 1][1] !== cells[i][0]) {
          array_swap(cells[i], 1, 0);
        }
      }
      return cells;
    } else {
      // sort other cells by adjacency and parallelity
      max_shared_edges = 2 ** (n - k - 2);
      includes_edge = function(a, b) {
        return a.find(function(a) {
          return edge_equal(a, b);
        });
      };
      is_adjacent_parallel = function(a, b) {
        return any_square(a, function(a) {
          return any_square(b, function(b) {
            var shared;
            shared = intersection(a, b, max_shared_edges, includes_edge);
            if (shared) {
              // checks that only the x-axis differs. could be extended
              if (1 === (shared[0][0] ^ shared[0][1])) {
                return 2;
              } else {
                return 1;
              }
            } else {
              return 0;
            }
          });
        });
      };
      return sort_by_predicate(cells, is_adjacent_parallel);
    }
  };

  get_n_cube_cells = function(n) {
    var ref, subcells;
    // integer -> array
    // get edges grouped by nested cells
    subcells = function(cells, k) {
      var a, cell_length;
      if (k < n) {
        cell_length = 2 ** (n - k);
        cells = group_n_cells(cells, n, k, cell_length);
        cells = (function() {
          var l, len, results;
          results = [];
          for (l = 0, len = cells.length; l < len; l++) {
            a = cells[l];
            results.push(subcells(a, k + 1));
          }
          return results;
        })();
        return sort_cells_by_edges(cells, n, k, cell_length);
      } else {
        return cells;
      }
    };
    return subcells((function() {
      var results = [];
      for (var l = 0, ref = 2 ** n; 0 <= ref ? l < ref : l > ref; 0 <= ref ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this), 1);
  };

  bits_to_array = function(a, n) {
    return (function() {
      var results = [];
      for (var l = 0; 0 <= n ? l < n : l > n; 0 <= n ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this).map(function(b, i) {
      if (0 === (a >> i & 1)) {
        return -1;
      } else {
        return 1;
      }
    });
  };

  array_map_leafs = function(a, f) {
    return a.map(function(a) {
      if (Array.isArray(a)) {
        return array_map_leafs(a, f);
      } else {
        return f(a);
      }
    });
  };

  random_color = function() {
    return [Math.floor(Math.random() * 256), Math.floor(Math.random() * 256), Math.floor(Math.random() * 256)];
  };

  color_to_string = function(a) {
    return `rgb(${a[0]}, ${a[1]}, ${a[2]})`;
  };

  vertex_distance = function(a) {
    return Math.sqrt(a.map(function(a) {
      return a * a;
    }));
  };

  line_midpoint = function(a, b) {
    return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
  };

  available_colors = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(function(a) {
    return random_color();
  });

  adjust_color_brightness = function(a, factor) {
    return a.map(function(a) {
      return Math.min(255, Math.max(0, a * factor));
    });
  };

  perspective_project = function(plane_width, plane_height, vertex_distance) {
    var effective_distance, scale, x, y, z;
    effective_distance = a.slice(3).reduce((function(sum, a) {
      return sum - a;
    }), vertex_distance);
    scale = vertex_distance / effective_distance;
    x = x * scale;
    y = y * scale;
    z = z * scale;
    return [x, y, z];
  };

  create_canvas_gradient = function() {
    var gradient;
    gradient = ctx.createLinearGradient(1, 2, 3, 4);
    gradient.addColorStop(0, "");
    return gradient.addColorStop(1, "");
  };

  render_rotating_cube = function(options) {
    var angle, base_distance, canvas, canvas_height, canvas_width, cells, ctx, dimensions, draw, f, interval, light_vector, refresh, render_square_path, render_vertex, rotate, rotate_dimensions, rotate_f, rotation_speed, space;
    // object -> interval
    // repeatedly draw and rotate a cube on an html canvas.
    dimensions = options.dimensions || 3;
    // elements set to zero are not rotated
    rotate_dimensions = options.rotate_dimensions || [];
    // in milliseconds
    refresh = options.refresh || 20;
    // in radians
    rotation_speed = options.rotation_speed || 0.008;
    // in pixel
    canvas_width = options.canvas_width || 800;
    canvas_height = options.canvas_height || 400;
    base_distance = 3;
    light_vector = [0, -1, 0];
    rotate_f = function(space) {
      var rotators;
      // one rotation function per plane
      rotators = Array(dimensions).fill(0).map(function(a, index) {
        var data, ia, ib;
        if (0 === rotate_dimensions[index]) {
          return function(a, angle) {
            return a;
          };
        }
        data = Array(dimensions).fill(0);
        ia = (index + 1) % dimensions;
        ib = index;
        return function(a, angle) {
          var rotor;
          angle = angle + ((ia + 1) * 1000);
          // array number -> array
          data[ia] = Math.cos(angle);
          data[ib] = Math.sin(angle);
          // create a versorjs object
          rotor = space.Vec.apply(this, data);
          return space.Vec.apply(this, a).sp(rotor).toArray();
        };
      });
      return function(a, angle) {
        var f;
        // apply all rotation functions to the given point vector
        f = function(a, rotate) {
          return a && rotate(a, angle);
        };
        return rotators.reduce(f, a);
      };
    };
    render_square_path = function(a) {
      var b, distance, midpoint, midpoint_distance;
      midpoint = line_midpoint(a[0][0], a[2][0]);
      midpoint_distance = vertex_distance(midpoint);
      [b, distance] = render_vertex(a[0][0]);
      return [b, midpoint_distance];
    };
    draw = function(ctx, cells, render_vertex, angle) {
      var draw_cells;
      ctx.clearRect(0, 0, canvas_width, canvas_height);
      draw_cells = function(a, ai) {
        var color, color_string, distance, i, l, midpoint, point, ref;
        if (4 === a.length && 2 === a[0].length) {
          [point, distance] = render_vertex(a[0][0]);
          midpoint = ctx.beginPath();
          ctx.moveTo(point[0], point[1]);
          point = render_vertex(a[0][1]);
          ctx.lineTo(point[0], point[1]);
          for (i = l = 1, ref = a.length; (1 <= ref ? l < ref : l > ref); i = 1 <= ref ? ++l : --l) {
            point = render_vertex(a[i][1]);
            ctx.lineTo(point[0], point[1]);
          }
          ctx.closePath();
          //distance = vertex_distance
          color = available_colors[ai];
          color_string = color_to_string(adjust_color_brightness(color, 1));
          ctx.strokeStyle = color_string;
          ctx.fillStyle = color_string;
          return ctx.stroke();
        } else {
          //ctx.fill()
          return a.forEach(function(a, ai) {
            return draw_cells(a, ai);
          });
        }
      };
      draw_cells(cells, 0);
      return angle + rotation_speed;
    };
    canvas = document.getElementById("cube");
    if (!(canvas && canvas.getContext)) {
      return;
    }
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    ctx = canvas.getContext("2d");
    angle = 0;
    space = versor.create({
      metric: Array(dimensions).fill(1)
    });
    rotate = rotate_f(space);
    render_vertex = function(a) {
      var d;
      a = rotate(a, angle);
      d = vertex_distance(a);
      a = perspective_project(canvas_width, canvas_height, a, d);
      return [a, d];
    };
    cells = get_n_cube_cells(dimensions);
    cells = array_map_leafs(cells, (function(a) {
      return bits_to_array(a, dimensions);
    }));
    // called repeatedly and updates angle
    f = function() {
      return angle = draw(ctx, cells, render_vertex, angle);
    };
    interval = setInterval(f, refresh);
    return interval;
  };

  ui_controls = (function() {
    class ui_controls {
      label(text, content) {
        var label;
        return label = crel("label", text, content);
      }

      update() {
        var count, rot_dim;
        // start rendering with a new configuration
        this.options.dimensions = Math.max(1, false_if_nan(parseInt(this.dom.in.dim.value)) || this.options.dimensions);
        if (!this.warning_shown && 6 === this.options.dimensions) {
          count = 2 ** this.options.dimensions;
          alert("increasing dimensions can easily overload the browser. now continuing to create " + count + " vertices", "notice");
          this.warning_shown = true;
        }
        this.options.rotate_dimensions = this.dom.in.rot_dim.map(function(a) {
          if (a.checked) {
            return 1;
          } else {
            return 0;
          }
        });
        rot_dim = document.getElementById("rot_dim");
        rot_dim.innerHTML = "";
        this.dom.in.rot_dim = this.in_rot_dim_new();
        this.dom.in.rot_dim.forEach(function(a) {
          return rot_dim.appendChild(a);
        });
        this.options.rotation_speed = false_if_nan(parseFloat(this.dom.in.rot_speed.value)) || this.options.rotation_speed;
        this.cube_interval && clearInterval(this.cube_interval);
        return this.cube_interval = render_rotating_cube(this.options);
      }

      in_rot_dim_new() {
        var axes;
        // create a new array of checkboxes
        axes = binomial(this.options.dimensions, 2);
        return Array(axes).fill(0).map((a, index) => {
          a = crel("input", {
            type: "checkbox",
            value: index
          });
          a.checked = !(this.options.rotate_dimensions[index] === 0);
          a.addEventListener("change", this.update);
          return a;
        });
      }

      constructor() {
        var container, dim, in_dim, in_rot_dim, in_rot_speed, rot_dim, rot_speed;
        this.update = this.update.bind(this);
        this.in_rot_dim_new = this.in_rot_dim_new.bind(this);
        // create input fields and container
        in_dim = crel("input", {
          type: "number",
          value: this.options.dimensions
        });
        in_rot_speed = crel("input", {
          type: "number",
          step: "0.001",
          value: this.options.rotation_speed
        });
        in_rot_dim = this.in_rot_dim_new();
        rot_dim = crel("div", this.label("rotate"), crel("span", {
          id: "rot_dim"
        }, in_rot_dim));
        rot_speed = this.label("speed", in_rot_speed);
        dim = this.label("dimensions", in_dim);
        this.dom.in = {
          dim: in_dim,
          rot_dim: in_rot_dim,
          rot_speed: in_rot_speed
        };
        [in_dim, in_rot_speed].forEach((a) => {
          return a.addEventListener("change", this.update);
        });
        container = crel("div", dim, rot_dim, rot_speed);
        document.getElementById("controls").appendChild(container);
        this.update();
      }

    };

    // creates the html for the controls and default options
    ui_controls.prototype.options = {
      dimensions: 3,
      rotate_dimensions: [1, 0, 1, 1],
      refresh: 200,
      rotation_speed: 0.001,
      canvas_width: 1000,
      canvas_height: 800
    };

    ui_controls.prototype.dom = {};

    ui_controls.prototype.warning_shown = false;

    return ui_controls;

  }).call(this);

  new ui_controls();

}).call(this);
